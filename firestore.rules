
/**
 * Core Philosophy:
 * This ruleset enforces a security model with a clear separation between public and private data.
 * Publicly browsable content, like courses, allows for open read access but restricts write
 * operations to the content creators (instructors). Private user-specific data, such as student
 * profiles and their course enrollments, is strictly confined to the authenticated owner of that data.
 *
 * Data Structure:
 * The data is organized into three top-level collections:
 * - /courses: A public collection of all available courses.
 * - /instructors: A restricted collection for instructor profiles.
 * - /users: Contains individual user profiles, with each user's data isolated under their
 *   unique user ID (`/users/{userId}`).
 * Nested within each user's document is an `/enrollments` subcollection, which is private to that user.
 *
 * Key Security Decisions:
 * - User Isolation: A user can only write to their own profile and data under `/users/{userId}`.
 *   To support community features like messaging, other authenticated users are allowed to read
 *   user profiles. It is critical that only publicly-safe information is stored in user documents.
 * - Admin Access: An admin panel, authenticated via a special anonymous session, has elevated
 *   privileges for managing data across the platform.
 * - Public Content Model: The `/courses` collection is readable by anyone, including unauthenticated
 *   users, to allow for creating, updating, or deleting a course is restricted
 *   to the instructor who owns it, identified by the `instructorId` field on the course document.
 * - Restricted Collections: The `/instructors` collection is currently locked down entirely. An
 *   admin-level role or specific business logic (e.g., via Cloud Functions) is required to manage this data.
 * - Denormalization for Authorization: To ensure fast and secure rule evaluation, authorization
 *   data is stored directly on the documents being secured. For example, the `instructorId` on a
 *   course document avoids the need for slow and costly lookups to other collections.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------
    // Helper Functions
    // --------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing data ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Verifies that a document exists before an update or delete operation.
     * This prevents writes to non-existent paths.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Combines ownership and existence checks for secure updates and deletes.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }
    
    /**
     * Checks if the user is an admin by verifying their sign-in provider.
     * This aligns with the front-end's use of signInAnonymously for the admin panel.
     * In this app's context, the admin panel's anonymous sign-in is sometimes identified
     * with the 'custom' provider. To ensure admin actions work, we allow both.
     */
    function isAnonymousAdmin() {
      return isSignedIn() && (request.auth.token.firebase.sign_in_provider == 'anonymous' || request.auth.token.firebase.sign_in_provider == 'custom');
    }

    /**
     * Ensures that on course creation, the instructorId field matches the creator's UID.
     */
    function isCreatorTheInstructor() {
      return request.resource.data.instructorId == request.auth.uid;
    }

    /**
     * Ensures the instructorId cannot be changed after a course is created.
     */
    function isInstructorImmutable() {
      return request.resource.data.instructorId == resource.data.instructorId;
    }

    /**
     * On user profile creation, ensures the document's 'id' field matches the user's auth UID.
     */
    function isUserIdConsistentOnCreate(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * Ensures the user 'id' field is immutable on update.
     */
    function isUserIdImmutable() {
      return request.resource.data.id == resource.data.id;
    }
    
    /**
     * On enrollment creation, ensures the document's 'studentId' field matches the parent user's auth UID.
     */
    function isStudentIdConsistentOnCreate(userId) {
      return request.resource.data.studentId == userId;
    }

    /**
     * Ensures the enrollment 'studentId' field is immutable on update.
     */
    function isStudentIdImmutable() {
      return request.resource.data.studentId == resource.data.studentId;
    }

    // --------------------------------
    // Collection Rules
    // --------------------------------

    /**
     * @description Controls access to the public collection of courses.
     * @path /courses/{courseId}
     * @allow (get) Any user, authenticated or not, can read a course.
     * @deny (create) An authenticated user tries to create a course where the `instructorId` does not match their own UID.
     * @principle Public Read with Owner-Only Writes. Course management is restricted to the instructor who created it.
     */
    match /courses/{courseId} {
      allow get, list: if true;
      allow create: if isSignedIn() && isCreatorTheInstructor();
      allow update: if isExistingOwner(resource.data.instructorId) && isInstructorImmutable();
      allow delete: if isExistingOwner(resource.data.instructorId);
    }

    /**
     * @description Controls access to instructor profiles.
     * @path /instructors/{instructorId}
     * @allow (create) An instructor can create their own profile.
     * @allow (get, list) Publicly readable to display on course and instructor pages.
     * @allow (update) An instructor can update their own profile, or an admin can update any profile.
     * @allow (delete) An instructor can delete their own profile, or an admin can delete any profile.
     * @principle Owner-creatable, public-readable, owner/admin-managed.
     */
    match /instructors/{instructorId} {
      allow create: if isOwner(instructorId);
      allow get, list: if true;
      allow update: if isOwner(instructorId) || isAnonymousAdmin();
      allow delete: if isOwner(instructorId) || isAnonymousAdmin();
    }

    /**
     * @description Secures student profile data.
     * @path /users/{userId}
     * @allow (get, list) Authenticated users and admins can read/list profiles to enable messaging.
     * @deny (get) A user (`user_abc`) tries to read another user's profile (`/users/user_xyz`).
     * @deny (list) A standard signed-in user cannot list all user profiles.
     * @principle Restricts access to a user's own data tree and enforces relational integrity.
     */
    match /users/{userId} {
      allow get, list: if isSignedIn() || isAnonymousAdmin();
      allow create: if isOwner(userId) && isUserIdConsistentOnCreate(userId);
      allow update: if isExistingOwner(userId) && isUserIdImmutable();
      allow delete: if isOwner(userId) || isAnonymousAdmin();

      /**
       * @description Secures a user's private enrollment records.
       * @path /users/{userId}/enrollments/{enrollmentId}
       * @allow (list) An authenticated user can list their own enrollments.
       * @deny (get) A user (`user_abc`) tries to read an enrollment from another user's path (`/users/user_xyz/enrollments/...`).
       * @principle Path-based ownership. Access is inherited and enforced from the parent user document.
       */
      match /enrollments/{enrollmentId} {
        allow get, list: if isOwner(userId) || isAnonymousAdmin();
        allow create: if isOwner(userId) && isStudentIdConsistentOnCreate(userId);
        allow update: if isExistingOwner(userId) && isStudentIdImmutable();
        allow delete: if isOwner(userId) || isAnonymousAdmin();
      }
    }
    
    /**
     * @description The "Vault". Secures instructor earnings.
     * @path /wallets/{userId}
     * @allow (read) The owner (instructor) or an admin can read the wallet.
     * @allow (write) No one can write to the wallet from the client. This must be done via a server-side Cloud Function.
     * @principle Secure by default. All financial transactions are server-authoritative.
     */
    match /wallets/{userId} {
      allow read: if isOwner(userId) || isAnonymousAdmin();
      allow create: if isOwner(userId); // Allow initial creation on signup
      allow delete: if isOwner(userId) || isAnonymousAdmin();
      allow update, list: if false;
    }

    /**
     * @description Stores instructor withdrawal requests.
     * @path /payout_requests/{requestId}
     * @allow (create) An authenticated user can create a payout request.
     * @allow (read, list, update) Only admins can manage payout requests.
     * @principle User-initiated, admin-managed workflow.
     */
    match /payout_requests/{requestId} {
        allow create: if isSignedIn() && request.resource.data.instructorId == request.auth.uid;
        allow read, list, update: if isAnonymousAdmin();
        allow delete: if false; // Requests should be processed, not deleted.
    }
    
    /**
     * @description Stores submissions from the public contact form.
     * @path /contact_submissions/{submissionId}
     * @allow (create) Anyone can submit the contact form.
     * @allow (read, list, update, delete) Only admins can manage submissions.
     * @principle Public write, admin-only management.
     */
    match /contact_submissions/{submissionId} {
        allow create: if true;
        allow read, list, update, delete: if isAnonymousAdmin();
    }

    /**
     * @description Public chat room for all users.
     * @path /public_chat/{messageId}
     * @allow (read, list) Any signed-in user can read messages.
     * @allow (create) Any signed-in user can send a message, but they can't impersonate another user.
     * @principle Community-driven open channel.
     */
    match /public_chat/{messageId} {
      allow read, list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      // Nobody can update or delete messages from the client.
      allow update, delete: if false;
    }
  }
}
