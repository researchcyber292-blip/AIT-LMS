
/**
 * Core Philosophy:
 * This ruleset enforces a security model with a clear separation between public and private data.
 * Publicly browsable content, like courses, allows for open read access but restricts write
 * operations to the content creators (instructors). Private user-specific data, such as student
 * profiles and their course enrollments, is strictly confined to the authenticated owner of that data.
 *
 * Data Structure:
 * The data is organized into three top-level collections:
 * - /courses: A public collection of all available courses.
 * - /instructors: A restricted collection for instructor profiles.
 * - /users: Contains individual user profiles, with each user's data isolated under their
 *   unique user ID (`/users/{userId}`).
 * Nested within each user's document is an `/enrollments` subcollection, which is private to that user.
 *
 * Key Security Decisions:
 * - User Isolation: A user can only write to their own profile and data under `/users/{userId}`.
 *   To support community features like messaging, other authenticated users are allowed to read
 *   user profiles. It is critical that only publicly-safe information is stored in user documents.
 * - Admin Access: An admin panel, authenticated via a special anonymous session, has elevated
 *   privileges for managing data across the platform.
 * - Public Content Model: The `/courses` collection is readable by anyone, including unauthenticated
 *   users, to allow for creating, updating, or deleting a course is restricted
 *   to the instructor who owns it, identified by the `instructorId` field on the course document.
 * - Restricted Collections: The `/instructors` collection is currently locked down entirely. An
 *   admin-level role or specific business logic (e.g., via Cloud Functions) is required to manage this data.
 * - Denormalization for Authorization: To ensure fast and secure rule evaluation, authorization
 *   data is stored directly on the documents being secured. For example, the `instructorId` on a
 *   course document avoids the need for slow and costly lookups to other collections.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------
    // Helper Functions
    // --------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing data ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the authenticated user is a registered instructor.
     */
    function isInstructor(userId) {
      return exists(/databases/$(database)/documents/instructors/$(userId));
    }

    /**
     * Verifies that a document exists before an update or delete operation.
     * This prevents writes to non-existent paths.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Combines ownership and existence checks for secure updates and deletes.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }
    
    /**
     * Checks if the user is an admin by verifying their sign-in provider.
     * This aligns with the front-end's use of signInAnonymously for the admin panel.
     * In this app's context, the admin panel's anonymous sign-in is sometimes identified
     * with the 'custom' provider. To ensure admin actions work, we allow both.
     */
    function isAnonymousAdmin() {
      return isSignedIn() && (request.auth.token.firebase.sign_in_provider == 'anonymous' || request.auth.token.firebase.sign_in_provider == 'custom');
    }

    /**
     * Checks if the authenticated user is a participant in the private chat.
     */
    function isChatParticipant(chatId) {
      return isSignedIn() && (request.auth.uid in chatId.split('_'));
    }

    /**
     * Ensures that on course creation, the instructorId field matches the creator's UID.
     */
    function isCreatorTheInstructor() {
      return request.resource.data.instructorId == request.auth.uid;
    }

    /**
     * Ensures the instructorId cannot be changed after a course is created.
     */
    function isInstructorImmutable() {
      return request.resource.data.instructorId == resource.data.instructorId;
    }

    /**
     * On user profile creation, ensures the document's 'id' field matches the user's auth UID.
     */
    function isUserIdConsistentOnCreate(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * Ensures the user 'id' field is immutable on update.
     */
    function isUserIdImmutable() {
      return request.resource.data.id == resource.data.id;
    }
    
    /**
     * On enrollment creation, ensures the document's 'studentId' field matches the parent user's auth UID.
     */
    function isStudentIdConsistentOnCreate(userId) {
      return request.resource.data.studentId == userId;
    }

    /**
     * Ensures the enrollment 'studentId' field is immutable on update.
     */
    function isStudentIdImmutable() {
      return request.resource.data.studentId == resource.data.studentId;
    }

    /**
     * Gets user data for rule evaluation.
     */
    function getUserData(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    /**
     * Checks if a student has quota to send a message in the public chat.
     * Instructors and admins have no limits.
     */
    function hasMessageQuota() {
      // Admins and instructors are not subject to message limits.
      if (isAnonymousAdmin() || isInstructor(request.auth.uid)) {
        return true;
      }
      
      let userData = getUserData(request.auth.uid);
      // Deny if the user document or the stats object doesn't exist.
      if (!('publicChatStats' in userData) || !('weekStartTimestamp' in userData.publicChatStats)) {
        return false;
      }
      
      let stats = userData.publicChatStats;
      let isNewWeek = request.time > stats.weekStartTimestamp + duration.value(7, 'd');
      
      // Allow if it's a new week (client will reset count) or if count is under limit.
      return isNewWeek || stats.messageCount < 50;
    }

    /**
     * Validates updates to the publicChatStats field on a user's profile.
     * Ensures counts are only incremented or reset correctly.
     */
    function isValidPublicChatStatsUpdate() {
      let existingData = resource.data;
      let newData = request.resource.data;

      // This rule only applies to updates of the publicChatStats field.
      if (!('publicChatStats' in newData)) {
        return true; 
      }

      // If stats didn't exist before (e.g., for an old user), allow initial creation.
      if (!('publicChatStats' in existingData)) {
        return newData.publicChatStats.messageCount == 1 
               && newData.publicChatStats.weekStartTimestamp == request.time;
      }
      
      let existingStats = existingData.publicChatStats;
      let newStats = newData.publicChatStats;
      let isNewWeek = request.time > existingStats.weekStartTimestamp + duration.value(7, 'd');
      
      if (isNewWeek) {
        // For a new week, the count must reset to 1 and the timestamp must update to now.
        return newStats.messageCount == 1 && newStats.weekStartTimestamp == request.time;
      } else {
        // For the same week, the count must increment by exactly 1 and the timestamp must NOT change.
        return newStats.messageCount == existingStats.messageCount + 1
               && newStats.weekStartTimestamp == existingStats.weekStartTimestamp;
      }
    }


    // --------------------------------
    // Collection Rules
    // --------------------------------

    /**
     * @description Controls access to the public collection of courses.
     * @path /courses/{courseId}
     * @allow (get) Any user, authenticated or not, can read a course.
     * @deny (create) An authenticated user tries to create a course where the `instructorId` does not match their own UID.
     * @principle Public Read with Owner-Only Writes. Course management is restricted to the instructor who created it.
     */
    match /courses/{courseId} {
      allow get, list: if true;
      allow create: if isSignedIn() && isInstructor(request.auth.uid) && isCreatorTheInstructor();
      allow update: if isExistingOwner(resource.data.instructorId) && isInstructorImmutable();
      allow delete: if isExistingOwner(resource.data.instructorId);
    }

    /**
     * @description Controls access to instructor profiles.
     * @path /instructors/{instructorId}
     * @allow (create) An instructor can create their own profile.
     * @allow (get, list) Publicly readable to display on course and instructor pages.
     * @allow (update) An instructor can update their own profile, or an admin can update any profile.
     * @allow (delete) An instructor can delete their own profile, or an admin can delete any profile.
     * @principle Owner-creatable, public-readable, owner/admin-managed.
     */
    match /instructors/{instructorId} {
      allow create: if isOwner(instructorId);
      allow read: if true;
      allow update: if isOwner(instructorId) || isAnonymousAdmin();
      allow delete: if isOwner(instructorId) || isAnonymousAdmin();
    }

    /**
     * @description Secures student profile data.
     * @path /users/{userId}
     * @allow (get, list) Authenticated users and admins can read/list profiles to enable messaging.
     * @principle Restricts access to a user's own data tree and enforces relational integrity.
     */
    match /users/{userId} {
      allow get, list: if isSignedIn() || isAnonymousAdmin();
      allow create: if isOwner(userId) && isUserIdConsistentOnCreate(userId);
      allow update: if isExistingOwner(userId) && isUserIdImmutable() && isValidPublicChatStatsUpdate();
      allow delete: if isOwner(userId) || isAnonymousAdmin();

      /**
       * @description Secures a user's private enrollment records.
       * @path /users/{userId}/enrollments/{enrollmentId}
       * @allow (list) An authenticated user can list their own enrollments.
       * @deny (get) A user (`user_abc`) tries to read an enrollment from another user's path (`/users/user_xyz/enrollments/...`).
       * @principle Path-based ownership. Access is inherited and enforced from the parent user document.
       */
      match /enrollments/{enrollmentId} {
        allow get, list: if isOwner(userId) || isAnonymousAdmin();
        allow create: if isOwner(userId) && isStudentIdConsistentOnCreate(userId);
        allow update: if isExistingOwner(userId) && isStudentIdImmutable();
        allow delete: if isOwner(userId) || isAnonymousAdmin();
      }
    }
    
    /**
     * @description The "Vault". Secures instructor earnings.
     * @path /wallets/{userId}
     * @allow (read) The owner (instructor) or an admin can read the wallet.
     * @allow (write) No one can write to the wallet from the client. This must be done via a server-side Cloud Function.
     * @principle Secure by default. All financial transactions are server-authoritative.
     */
    match /wallets/{userId} {
      allow read: if isOwner(userId) || isAnonymousAdmin();
      allow create: if isOwner(userId); // Allow initial creation on signup
      allow delete: if isOwner(userId) || isAnonymousAdmin();
      allow update, list: if false;
    }

    /**
     * @description Stores instructor withdrawal requests.
     * @path /payout_requests/{requestId}
     * @allow (create) An authenticated user can create a payout request.
     * @allow (read, list, update) Only admins can manage payout requests.
     * @principle User-initiated, admin-managed workflow.
     */
    match /payout_requests/{requestId} {
        allow create: if isSignedIn() && request.resource.data.instructorId == request.auth.uid;
        allow read, list, update: if isAnonymousAdmin();
        allow delete: if false; // Requests should be processed, not deleted.
    }
    
    /**
     * @description Stores submissions from the public contact form.
     * @path /contact_submissions/{submissionId}
     * @allow (create) Anyone can submit the contact form.
     * @allow (read, list, update, delete) Only admins can manage submissions.
     * @principle Public write, admin-only management.
     */
    match /contact_submissions/{submissionId} {
        allow create: if true;
        allow read, list, update, delete: if isAnonymousAdmin();
    }

    /**
     * @description Public chat room for all users.
     * @path /public_chat/{messageId}
     * @allow (read, list) Any signed-in user can read messages.
     * @allow (create) Any signed-in user can send a message, but they can't impersonate another user and must have message quota.
     * @principle Community-driven open channel with rate limiting.
     */
    match /public_chat/{messageId} {
      allow read, list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid && hasMessageQuota();
      allow update, delete: if isOwner(resource.data.userId);
    }
    
    /**
     * @description Private one-on-one chats between users.
     * @path /private_chats/{chatId}
     * @allow (read, write) Only participants of the chat can access messages.
     * @principle Path-based ownership, derived from chat ID.
     */
    match /private_chats/{chatId} {
      // Rules are enforced on the subcollection.
      match /messages/{messageId} {
        allow read, list: if isChatParticipant(chatId);
        allow create: if isChatParticipant(chatId) && request.resource.data.userId == request.auth.uid;
        allow update, delete: if isChatParticipant(chatId) && isOwner(resource.data.userId);
      }
    }
    
    /**
     * @description Stores metadata about uploaded videos.
     * @path /course_videos/{videoId}
     * @allow (read) Publicly readable.
     * @allow (create) Instructors and admins can upload videos.
     * @allow (delete) Only anonymous admins can delete videos.
     * @principle Content management for authorized users.
     */
     match /course_videos/{videoId} {
      allow get, list: if true;
      allow create: if (isInstructor(request.auth.uid) || isAnonymousAdmin()) && request.resource.data.uploaderId == request.auth.uid;
      allow update: if false;
      allow delete: if isAnonymousAdmin() || isOwner(resource.data.uploaderId);
    }
  }
}
